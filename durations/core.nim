# Copyright 2022 Zack Guard
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

{.push raises: [].}

import std/rationals

export rationals.`*`

type
  Count* = int64
  Ratio* = Rational[Count]
  Duration*[R: static[Ratio]] = object
    ## Represents a duration in a particular unit.
    count*: Count

func init*(D: typedesc[Duration]; count: Count): D =
  ## Initializes a duration.
  runnableExamples("--import:durations"):
    discard Seconds.init(5)

  D(count: count)

func `//`*(num, denom: Count): Ratio =
  ## Initializes a ratio with the given numerator and denominator.
  runnableExamples:
    discard 1000 // 1

  initRational(num, denom)

func `$`*(d: Duration): string =
  ## Returns a generic string representation of the duration. This is overloaded
  ## for duration types generated by the `unit` macro, including the built-in
  ## ones.
  "Duration[" & $d.R & "](" & $d.count & ")"

func toCount(x: Ratio): Count =
  # Same as std/rationals.toInt
  x.num div x.den

func to*[R1, R2](d: Duration[R1]; outType: typedesc[Duration[R2]]): Duration[R2] =
  ## Converts `d` to the specified unit, truncating if necessary.
  runnableExamples("--import:durations"):
    assert 1250.milliseconds.to(Seconds) == 1.seconds
    assert 1.seconds.to(Milliseconds) == 1000.milliseconds

  when R1 == R2:
    d
  else:
    const conversion = R1 / R2
    Duration[R2](count: (d.count * conversion).toCount)

template operatorImpl[R1, R2](d1: Duration[R1]; d2: Duration[R2]; expression: untyped; wrap = false): untyped =
  const commonRatio =
    when R2 < R1: R2
    else: R1
  let
    a {.inject.} = d1.to(Duration[commonRatio]).count
    b {.inject.} = d2.to(Duration[commonRatio]).count
  when wrap:
    Duration[commonRatio](count: expression)
  else:
    expression

template arithImpl[R1, R2](d1: Duration[R1]; d2: Duration[R2]; expression: untyped): untyped =
  operatorImpl(d1, d2, expression, true)

func `+`*[R1, R2](d1: Duration[R1]; d2: Duration[R2]): auto =
  ## Sums two durations, converting to higher precision if necessary.
  runnableExamples("--import:durations"):
    assert 1.seconds + 250.milliseconds == 1250.milliseconds

  arithImpl(d1, d2, a + b)

func `+=`*[R](d1: var Duration[R]; d2: Duration[R]) =
  ## Modifies `d1` by adding `d2` to it.
  runnableExamples("--import:durations"):
    var d = 250.milliseconds
    d += 5.seconds.to(Milliseconds)
    assert d == 5250.milliseconds

  d1 = d1 + d2

func `-`*[R1, R2](d1: Duration[R1]; d2: Duration[R2]): auto =
  ## Subtracts two durations, converting to higher precision if necessary.
  runnableExamples("--import:durations"):
    assert 1.seconds - 250.milliseconds == 750.milliseconds

  arithImpl(d1, d2, a - b)

func `*`*[R](d: Duration[R]; n: SomeInteger): Duration[R] =
  ## Multiplies a duration by an integer.
  runnableExamples("--import:durations"):
    assert 333.seconds * 3 == 999.seconds

  Duration[R](count: d.count * n)

func `*`*[R; N: SomeFloat](d: Duration[R]; n: N): Duration[R] =
  ## Multiplies a duration by a float, truncating if necessary.
  runnableExamples("--import:durations"):
    assert 1000.seconds * 3.14159 == 3141.seconds

  Duration[R](count: (d.count.N * n).Count)

func `*`*[R](n: SomeNumber; d: Duration[R]): Duration[R] =
  d * n

func `div`*[R](d: Duration[R]; n: SomeInteger): Duration[R] =
  ## Divides a duration by an integer, truncating if necessary.
  runnableExamples("--import:durations"):
    assert 33.seconds div 10 == 3.seconds

  Duration[R](count: d.count div n)

func `div`*[R; N: SomeFloat](d: Duration[R]; n: N): Duration[R] =
  ## Divides a duration by a float, truncating if necessary.
  runnableExamples("--import:durations"):
    assert 100.seconds div 1.1 == 90.seconds

  Duration[R](count: (d.count.N / n).Count)

func `div`*[R1, R2](d1: Duration[R1]; d2: Duration[R2]): Count =
  ## Divides two durations, truncating if necessary.
  runnableExamples("--import:durations"):
    assert 10.seconds div 4.seconds == 2

  operatorImpl(d1, d2, a div b)

func `/`*[R1, R2](d1: Duration[R1]; d2: Duration[R2]): float =
  ## Divides two durations.
  runnableExamples("--import:durations"):
    assert 10.seconds / 4.seconds == 2.5

  operatorImpl(d1, d2, a.float / b.float)

func `==`*[R1, R2](d1: Duration[R1]; d2: Duration[R2]): bool =
  ## Checks whether the two durations represent the same quantity.
  runnableExamples("--import:durations"):
    assert 1.seconds == 1000.milliseconds

  operatorImpl(d1, d2, a == b)

func `<=`*[R1, R2](d1: Duration[R1]; d2: Duration[R2]): bool =
  ## Checks whether `d1` is less than or equal to `d2`.
  runnableExamples("--import:durations"):
    assert 500.milliseconds <= 1.seconds

  operatorImpl(d1, d2, a <= b)

func `<`*[R1, R2](d1: Duration[R1]; d2: Duration[R2]): bool =
  ## Checks whether `d1` is less than `d2`.
  runnableExamples("--import:durations"):
    assert 500.milliseconds < 1.seconds

  operatorImpl(d1, d2, a < b)

func ceil*[R1, R2](d: Duration[R1]; To: typedesc[Duration[R2]]): Duration[R2] =
  ## Rounds `d` up to the specified unit.
  runnableExamples("--import:durations"):
    assert 3500.milliseconds.ceil(Seconds) == 4.seconds

  result = d.to(Duration[R2])
  if result < d:
    result += Duration[R2](count: 1)

func floor*[R1, R2](d: Duration[R1]; To: typedesc[Duration[R2]]): Duration[R2] =
  ## Rounds `d` down to the specified unit.
  runnableExamples("--import:durations"):
    assert 3500.milliseconds.floor(Seconds) == 3.seconds

  d.to(Duration[R2])
